for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[1, i] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[j, i] <- symulacje[j-1, i] + sim_res[j]
}
}
res2
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- cumsum(forecast(model2, h)$mean + sim_residuals)
}
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- cumsum(forecast(model2, h)$mean + sim_res)
}
sim_res
cumsum(forecast(model2, h)$mean + sim_res)
symulacje[, 1]
symulacje
symulacje <- matrix(0, nrow = h, ncol = n)
symulacje[, 1]
symulacje[, 1] <- cumsum(forecast(model2, h)$mean + sim_res)
n <- 1000
# Długość prognozy (4 notowania)
h <- 4
symulacje <- matrix(0, nrow = h, ncol = n)
# Wartość początkowa logarytmów cen (ostatnia znana wartość w cenach)
last_price <- tail(ceny, 1)
# Symulacje Monte Carlo
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- cumsum(forecast(model2, h)$mean + sim_res)
}
symulacje
ceny
last_price
rowMeans(symulacje)
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- (cumsum(forecast(model2, h)$mean + sim_res) + last_price)
}
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- (cumsum(forecast(model2, h)$mean + sim_res))
}
symulacje <- matrix(0, nrow = h, ncol = n)
# Wartość początkowa logarytmów cen (ostatnia znana wartość w cenach)
last_price <- tail(ceny, 1)
# Symulacje Monte Carlo
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- (cumsum(forecast(model2, h)$mean + sim_res))
}
symulacje
rowMeans(symulacje)
# Symulacje Monte Carlo
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = h, ncol = n)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- (cumsum(forecast(model2, h)$mean + sim_res) + last_price)
}
# Symulacje Monte Carlo
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = h, ncol = n)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[, i] <- (cumsum(forecast(model2, h)$mean + sim_res))
}
rowMeans(symulacje)
symulacje[1, 5]
symulacje[5, 5]
# Symulacje Monte Carlo
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = h, ncol = n)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[1, i] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[j, i] <- symulacje[j-1, i] + sim_res[j]
}
}
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = h, ncol = n)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[1, i] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[j, i] <- (symulacje[(j-1), i] + sim_res[j])
}
}
symulacje
symulacje <- matrix(0, nrow = h, ncol = n)
symulacje
View(symulacje)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[1, i] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[j, i] <- (symulacje[(j-1), i] + sim_res[j])
}
}
symulacje
sim_res
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[i, 1] <- (last_price + sim_res[1])
for (j in 2:h) {
symulacje[i, j] <- (symulacje[i, j-1] + sim_res[j])
}
}
symulacje
symulacje <- matrix(0, nrow = n, ncol = h)
sim_res
symulacje[1, 1] <- (last_price + sim_res[1])
(last_price + sim_res[1])
unname(last_price + sim_res[1])
symulacje <- matrix(0, nrow = n, ncol = h)
symulacje[1, 1] <- unname(last_price + sim_res[1])
unname(last_price + sim_res[1])
as.numeric(last_price + sim_res[1])
symulacje <- matrix(0, nrow = n, ncol = h)
symulacje[1, 1] <- as.numeric(last_price + sim_res[1])
sim_res
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[i, 1] <- as.numeric(last_price + sim_res[1])
for (j in 2:h) {
symulacje[i, j] <- (symulacje[i, j-1] + sim_res[j])
}
}
colMeans(symulacje)
ceny_oct
ceny_oct
ceny
indeksy
dt
stopy
ceny
dane
ceny <- unname(head(log(dane[2]), -4))
ceny
stopy_oct
ceny_oct
ceny_n
dane
izo <- read.csv("izo_d.csv")
#Stopa logarytmiczna
st_l <- function(a,b) {
return(log(a/b))
}
#Zaczytanie danych
dane <- unname(izo[,c(1,5)])
indeksy <- dane %>% map_df(rev)
izo <- read.csv("izo_d.csv")
#Stopa logarytmiczna
st_l <- function(a,b) {
return(log(a/b))
}
#Zaczytanie danych
dane <- izo[,c(1,5)]
indeksy <- dane %>% map_df(rev)
#Wyliczanie stóp logarytmicznych
dt <- c()
for (i in 1:(nrow(indeksy)-1)) {
dt <- c(dt,as.numeric(st_l(indeksy[i,2],indeksy[i+1,2])))
}
ceny <- unname(head(log(dane[2]), -4))
ceny
ceny_oct <- unname(tail(log(dane[2]), 4))
ceny_n <- unname(tail(dane[2], 4))
ceny_wyniki <- data.frame(
Odłożone_Wartości = ceny_oct,
Początek_Przedziału = forecast(model2,4)$lower[, 2],
Koniec_Przedziału = forecast(model2,4)$upper[, 2],
Średnia_Prognoza = forecast(model2,4)$mean
)
ceny_wyniki
last_price + sim_res[1]
last_price <- tail(ceny, 1)
last_price
last_price + sim_res[1]
as.numeric(last_price + sim_res[1])
as.numeric(last_price + sim_res[1])
sim_res[1]
last_price
last_price + sim_res[1]
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[i, 1] <- as.numeric(last_price + sim_res[1])
for (j in 2:h) {
symulacje[i, j] <- (symulacje[i, j-1] + sim_res[j])
}
}
symulacje
last_price
last_price
as.numeric(tail(ceny, 1))
last_price + sim_res[1]
sim_res[1]
(last_price + sim_res[1])
last_price
last_price <- as.numeric(tail(ceny, 1))
last_price
last_price + sim_res[1]
as.numeric(last_price + sim_res[1])
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
symulacje[i, 1] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[i, j] <- (symulacje[i, j-1] + sim_res[j])
}
}
# Obliczenie 95% przedziałów ufności dla logarytmów cen
log_price_forecast_mean <- colMeans(symulacje)
log_price_forecast_lower <- apply(symulacje, 2, quantile, probs = 0.025)
log_price_forecast_upper <- apply(symulacje, 2, quantile, probs = 0.975)
# Konwersja logarytmów cen do rzeczywistych cen
symulacje_ceny <- exp(symulacje)
# Obliczenie 95% przedziałów ufności dla rzeczywistych cen
price_forecast_mean <- colMeans(symulacje_ceny)
price_forecast_lower <- apply(symulacje_ceny, 2, quantile, probs = 0.025)
price_forecast_upper <- apply(symulacje_ceny, 2, quantile, probs = 0.975)
# Tworzenie tabeli porównawczej wyników
wyniki_porownawcze <- data.frame(
Notowanie = 1:h,
Odłożone_Wartości_Log = ceny_oct,
Prognoza_Log_Ceny = log_price_forecast_mean,
Przedzial_Log_Ceny_Dolny = log_price_forecast_lower,
Przedzial_Log_Ceny_Gorny = log_price_forecast_upper,
Odłożone_Wartości = exp(ceny_oct),
Prognoza_Ceny = price_forecast_mean,
Przedzial_Ceny_Dolny = price_forecast_lower,
Przedzial_Ceny_Gorny = price_forecast_upper
)
wyniki_porownawcze
wyniki_porownawcze <- data.frame(
Odłożone_Wartości_Log = ceny_oct,
Prognoza_Log_Ceny = log_price_forecast_mean,
Przedzial_Log_Ceny_Dolny = log_price_forecast_lower,
Przedzial_Log_Ceny_Gorny = log_price_forecast_upper,
Odłożone_Wartości = exp(ceny_oct),
Prognoza_Ceny = price_forecast_mean,
Przedzial_Ceny_Dolny = price_forecast_lower,
Przedzial_Ceny_Gorny = price_forecast_upper
)
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
bootstrap <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
boot_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
bootstrap[i, 1] <- last_price + boot_res[1]
for (j in 2:h) {
bootstrap[i, j] <- (bootstrap[i, j-1] + boot_res[j])
}
}
# Obliczanie średnich prognoz i 95% przedziałów ufności dla logarytmów cen
log_price_forecast_mean <- colMeans(bootstrap_log_prices)
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
bootstrap <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
boot_res <- sample(res2, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
bootstrap[i, 1] <- last_price + boot_res[1]
for (j in 2:h) {
bootstrap[i, j] <- (bootstrap[i, j-1] + boot_res[j])
}
}
# Obliczanie średnich prognoz i 95% przedziałów ufności dla logarytmów cen
log_price_forecast_mean <- colMeans(bootstrap)
log_price_forecast_lower <- apply(bootstrap, 2, quantile, probs = 0.025)
log_price_forecast_upper <- apply(bootstrap, 2, quantile, probs = 0.975)
# Konwersja logarytmów cen na rzeczywiste ceny
bootstrap_prices <- exp(bootstrap)
# Obliczanie średnich prognoz i 95% przedziałów ufności dla rzeczywistych cen
price_forecast_mean <- colMeans(bootstrap_prices)
price_forecast_lower <- apply(bootstrap_prices, 2, quantile, probs = 0.025)
price_forecast_upper <- apply(bootstrap_prices, 2, quantile, probs = 0.975)
# Tworzenie tabeli wynikowej z prognozami i przedziałami ufności
wyniki_bootstrap <- data.frame(
Odłożone_Wartości_Log = ceny_oct,
Prognoza_Log_Ceny = log_price_forecast_mean,
Przedzial_Log_Ceny_Dolny = log_price_forecast_lower,
Przedzial_Log_Ceny_Gorny = log_price_forecast_upper,
Odłożone_Wartości = exp(ceny_oct),
Prognoza_Ceny = price_forecast_mean,
Przedzial_Ceny_Dolny = price_forecast_lower,
Przedzial_Ceny_Gorny = price_forecast_upper
)
wyniki_bootstrap
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- rnorm(h, mean(res2), sd(res2))
# Symulacja logarytmów cen przy użyciu modelu
symulacje[i, 1] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[i, j] <- (symulacje[i, j-1] + sim_res[j])
}
}
# Obliczenie 95% przedziałów ufności dla logarytmów cen
log_price_forecast_mean <- colMeans(symulacje)
log_price_forecast_lower <- apply(symulacje, 2, quantile, probs = 0.025)
log_price_forecast_upper <- apply(symulacje, 2, quantile, probs = 0.975)
# Konwersja logarytmów cen do rzeczywistych cen
symulacje_ceny <- exp(symulacje)
# Obliczenie 95% przedziałów ufności dla rzeczywistych cen
price_forecast_mean <- colMeans(symulacje_ceny)
price_forecast_lower <- apply(symulacje_ceny, 2, quantile, probs = 0.025)
price_forecast_upper <- apply(symulacje_ceny, 2, quantile, probs = 0.975)
# Tworzenie tabeli porównawczej wyników
wyniki_monte_carlo <- data.frame(
Odłożone_Wartości_Log = ceny_oct,
Prognoza_Log_Ceny = log_price_forecast_mean,
Przedzial_Log_Ceny_Dolny = log_price_forecast_lower,
Przedzial_Log_Ceny_Gorny = log_price_forecast_upper,
Odłożone_Wartości = exp(ceny_oct),
Prognoza_Ceny = price_forecast_mean,
Przedzial_Ceny_Dolny = price_forecast_lower,
Przedzial_Ceny_Gorny = price_forecast_upper
)
wyniki_monte_carlo
wyniki_bootstrap
price_forecast_mean_bootstrap <- colMeans(bootstrap_prices)
set.seed(123)  # Ustawienie ziarna dla powtarzalności wyników
symulacje <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- rnorm(h, mean(res2), sd(res2))
# Symulacja logarytmów cen przy użyciu modelu
symulacje[i, 1] <- last_price + sim_res[1]
for (j in 2:h) {
symulacje[i, j] <- (symulacje[i, j-1] + sim_res[j])
}
}
# Obliczenie 95% przedziałów ufności dla logarytmów cen
log_price_forecast_mean <- colMeans(symulacje)
log_price_forecast_lower <- apply(symulacje, 2, quantile, probs = 0.025)
log_price_forecast_upper <- apply(symulacje, 2, quantile, probs = 0.975)
# Konwersja logarytmów cen do rzeczywistych cen
symulacje_ceny <- exp(symulacje)
# Obliczenie 95% przedziałów ufności dla rzeczywistych cen
price_forecast_mean <- colMeans(symulacje_ceny)
price_forecast_lower <- apply(symulacje_ceny, 2, quantile, probs = 0.025)
price_forecast_upper <- apply(symulacje_ceny, 2, quantile, probs = 0.975)
log_price_forecast_mean_mc <- colMeans(symulacje)
#Porównanie obu metod
wyniki_porownawcze <- data.frame(
Odlozone_Wartosci = stopy_oct,
Prognoza_Monte_Carlo = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap
)
price_forecast_mean_bootstrap <- colMeans(bootstrap_prices)
wyniki_porownawcze <- data.frame(
Odlozone_Wartosci = stopy_oct,
Prognoza_Monte_Carlo = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap
)
log_price_forecast_mean_bootstrap <- colMeans(bootstrap)
wyniki_porownawcze <- data.frame(
Odlozone_Wartosci = stopy_oct,
Prognoza_Monte_Carlo = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap
)
wyniki_porownawcze
wyniki_porownawcze <- data.frame(
Odlozone_Wartosci = ceny_oct,
Prognoza_Monte_Carlo = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap
)
wyniki_porownawcze
install.packages("rugarch")
library(rugarch)
library("rugarch")
spec <- ugarchspec(
variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(3, 2), include.mean = TRUE),
distribution.model = "norm"
)
model_garch <- ugarchfit(spec = spec, data = ceny)
forecast_garch <- ugarchforecast(model_garch, n.ahead = h)
forecast_garch
fitted(forecast_garch)
log_garch_mean <- fitted(forecast_garch)
test_arch <- ArchTest(res2, lags = 10)
library("tseries")
test_arch <- ArchTest(res2, lags = 10)
install.packages(FinTS)
install.packages("FinTS")
library("FinTS")
test_arch <- ArchTest(res2, lags = 10)
test_arch
test_arch <- ArchTest(residuals(model_garch), lags = 10)
test_arch
test_arch1 <- ArchTest(res2, lags = 10)
test_arch2 <- ArchTest(residuals(model_garch), lags = 10)
test_arch1
test_arch1 <- ArchTest(res2)
test_arch1
test_arch2 <- ArchTest(residuals(model_garch))
test_arch2
res3 <- residuals(model_garch)
set.seed(123)
mcg <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
sim_res <- rnorm(h, mean(res3), sd(res3))
# Symulacja logarytmów cen przy użyciu modelu
mcg[i, 1] <- last_price + sim_res[1]
for (j in 2:h) {
mcg[i, j] <- (mcg[i, j-1] + sim_res[j])
}
}
set.seed(123)
bootg <- matrix(0, nrow = n, ncol = h)
for (i in 1:n) {
# Generowanie losowych reszt modelu
boot_res <- sample(res3, h, replace = TRUE)
# Symulacja logarytmów cen przy użyciu modelu
bootg[i, 1] <- last_price + boot_res[1]
for (j in 2:h) {
bootg[i, j] <- (bootg[i, j-1] + boot_res[j])
}
}
log_gmc_mean <- colMeans(mcg)
gmc_mean <- colMeans(exp(mcg))
log_bootg_mean <- colMeans(bootg)
bootg_mean <- colMeans(exp(bootg))
forecast(model2,4)$lower[, 2]
arima_forecast <- forecast(model2,4)$lower[, 2]
arima_forecast <- forecast(model2,4)$mean
arima_forecast
ostatnie_porównanie <- data.frame(
Odłożone_Wartości = ceny_oct,
Prognoza_ARIMA = arima_forecast,
Prognoza_MC = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap,
Prognoza_GARCH = forecast_garch,
Prognoza_MC_GARCH = log_gmc_mean,
Prognoza_Bootstrap_GARCH = log_bootg_mean
)
log_garch_mean
ostatnie_porównanie <- data.frame(
Odłożone_Wartości = ceny_oct,
Prognoza_ARIMA = arima_forecast,
Prognoza_MC = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap,
Prognoza_GARCH = log_garch_mean,
Prognoza_MC_GARCH = log_gmc_mean,
Prognoza_Bootstrap_GARCH = log_bootg_mean
)
ostatnie_porównanie
ostatnie_porównanie <- data.frame(
Odłożone_Wartości = ceny_oct,
Prognoza_ARIMA = arima_forecast,
Prognoza_MC = log_price_forecast_mean_mc,
Prognoza_Bootstrap = log_price_forecast_mean_bootstrap,
Prognoza_GARCH = unname(log_garch_mean),
Prognoza_MC_GARCH = log_gmc_mean,
Prognoza_Bootstrap_GARCH = log_bootg_mean
)
ostatnie_porównanie
